
This accurately reflects the unmodified contents of
[4.3.9. Headings and sections](https://w3c.github.io/html/sections.html#headings-and-sections):

* `html-specification`
* [W3C, HTML Editor's Draft, 18 July 2017](https://w3c.github.io/html)
* [W3C, Working Draft, 18 July 2017](https://www.w3.org/TR/html52)

## Definitions

Definition of [heading content](https://w3c.github.io/html/dom.html#heading-content-2):
Heading content defines the header of a section (whether explicitly marked up
using sectioning content elements, or implied by the heading content itself).
`=> h1, h2, h3, h4, h5, h6`.

Definition of [rank](https://w3c.github.io/html/sections.html#rank): These
elements have a rank given by the number in their name. The h1 element has
the highest rank, the h6 element has the lowest rank, and two elements with
the same name have equal rank.

Definition of [sectioning content](https://w3c.github.io/html/dom.html#sectioning-content-2):
Sectioning content is content that defines the scope of headings and footers.
Each sectioning content element potentially has a heading and an outline. See
the section on headings and sections for further details.
`=> article, aside, nav, section`.

## [4.3.9. Headings and sections](https://w3c.github.io/html/sections.html#headings-and-sections)

The h1–h6 elements are headings.

The first element of heading content in an element of sectioning content
represents the heading for that explicit section. Subsequent headings of equal
or higher rank start new implied subsections that are part of the previous
section’s parent section. Subsequent headings of lower rank start new implied
subsections that are part of the previous one. In both cases, the element
represents the heading of the implied section.

h1–h6 elements must not be used to markup subheadings, subtitles, alternative
titles and taglines unless intended to be the heading for a new section or
subsection. Instead use the markup patterns in the [§4.13 Common idioms without
dedicated elements](https://w3c.github.io/html/common-idioms-without-dedicated-elements.html#common-idioms-without-dedicated-elements)
section of the specification.

Certain elements are said to be [sectioning roots](https://w3c.github.io/html/sections.html#sectioning-roots),
including blockquote and td elements. These elements can have their own outlines,
but the sections and headings inside these elements do not contribute to the
outlines of their ancestors.
`=> blockquote, body, details, dialog, fieldset, figure, td`.

Sectioning content elements are always considered subsections of their nearest
ancestor sectioning root or their nearest ancestor element of sectioning content,
whichever is nearest, regardless of what implied sections other headings may
have created.

```
****************
** Example 24 **

For the following fragment:

<body>
  <h1>Foo</h1>
  <h2>Bar</h2>
  <blockquote>
    <h3>Bla</h3>
  </blockquote>
  <p>Baz</p>
  <h2>Quux</h2>
  <section>
    <h3>Thud</h3>
  </section>
  <p>Grunt</p>
</body>

...the structure would be:

1. Foo (heading of explicit body section,
   containing the "Grunt" paragraph)
   1. Bar (heading starting implied section,
      containing a block quote and the "Baz" paragraph)
   2. Quux (heading starting implied section
      with no content other than the heading itself)
   3. Thud (heading of explicit section section)

Notice how the section ends the earlier implicit section so
that a later paragraph ("Grunt") is back at the top level.

****************
```

Sections may contain headings of a rank equal to their section nesting level.
Authors should use headings of the appropriate rank for the section’s nesting
level.

Authors are also encouraged to explicitly wrap sections in elements of
sectioning content, instead of relying on the implicit sections generated by
having multiple headings in one element of sectioning content.

```
****************
** Example 25 **

For example, the following is correct:

<body>
  <h1>Apples</h1>
  <p>Apples are fruit.</p>
  <section>
    <h2>Taste</h2>
    <p>They taste lovely.</p>
    <h3>Sweet</h3>
    <p>Red apples are sweeter than green ones.</p>
    <h3>Color</h3>
    <p>Apples come in various colors.</p>
  </section>
</body>

However, the same document would be more clearly expressed as:

<body>
  <h1>Apples</h1>
  <p>Apples are fruit.</p>
  <section>
    <h2>Taste</h2>
    <p>They taste lovely.</p>
    <section>
      <h3>Sweet</h3>
      <p>Red apples are sweeter than green ones.</p>
    </section>
    <section>
      <h3>Color</h3>
      <p>Apples come in various colors.</p>
    </section>
  </section>
</body>

Both of the documents above are semantically identical and
would produce the same outline in compliant user agents.

****************
```

## [4.3.9.1. Creating an outline](https://w3c.github.io/html/sections.html#creating-an-outline)

Warning! - There are currently no known native implementations of the outline
algorithm in graphical browsers or assistive technology user agents, although
the algorithm is implemented in other software such as conformance checkers
and browser extensions. Therefore the outline algorithm cannot be relied upon
to convey document structure to users. Authors should use heading rank (h1-h6)
to convey document structure.

*This section is non-normative*

This section defines an algorithm for creating an outline for a sectioning
content element or a sectioning root element. It is defined in terms of a
walk over the nodes of a DOM tree, in tree order, with each node being visited
when it is entered and when it is exited during the walk. Each time a node
is visited, it can be seen as triggering an enter or exit event.

```
****************
** Example 26 **

The following pseudocode fragment:

visitNode(node)
  onEnter(node)
  child = node.firstChild
  while(child != null)
    visitNode(child)
    child = child.nextSibling
  onExit(node)

...exemplifies how to recursively traverse the node tree and when to trigger
the enter and exit events. See the JavaScript example for a possible,
non-recursive JavaScript implementation.

****************
```

The [outline](https://w3c.github.io/html/sections.html#outline) for a sectioning
content element or a sectioning root element consists of a list of one or more
potentially nested sections. The element for which an outline is created is said
to be [the outline’s owner](https://w3c.github.io/html/sections.html#the-outlines-owner).

A [section](https://w3c.github.io/html/sections.html#section) is a container
that corresponds to some nodes in the original DOM tree. Each section can have
one heading associated with it, and can contain any number of further nested
subsections. The algorithm for the outline also associates each node in the DOM
tree with a particular section and potentially a heading. (The sections in the
outline aren’t section elements, though some may correspond to such elements -
they are merely conceptual sections.)

```
****************
** Example 27 **

The following markup fragment:

<body>
  <h1>A</h1>
  <p>B</p>
  <h2>C</h2>
  <p>D</p>
  <h2>E</h2>
  <p>F</p>
</body>

...results in the following outline being created for the body node
(and thus the entire document):

1. Section created for body node. Associated with heading "A".
   Also associated with paragraph "B". Nested sections:
   1. Section implied for first h2 element. Associated with heading "C".
      Also associated with paragraph "D". No nested sections.
   2. Section implied for second h2 element. Associated with heading "E".
      Also associated with paragraph "F". No nested sections.

****************
```

The algorithm, i.e. anything in between Example 27 and Example 28,
is according to:

* [W3C, HTML Editor's Draft, 29 Dec 2017](https://w3c.github.io/html)

The algorithm that must be followed during a walk of a DOM subtree rooted at
a sectioning content element or a sectioning root element to determine that
element’s outline is as follows:

<table>
<!-- 1. init outline owner -->
<tr><td>1.</td><td></td><td>
Let current outline owner be null.
(It holds the element whose outline is being created.)</td></tr>

<!-- 2. init current section -->
<tr><td>2.</td><td></td><td>
Let current section be null. (It holds a pointer to a section,
so that elements in the DOM can all be associated with a section.)</td></tr>

<!-- 3. init stack -->
<tr><td>3.</td><td></td><td>
Create a stack to hold elements, which is used to handle nesting.
Initialize this stack to empty.</td></tr>

<!-- 4. do tree walk -->
<tr><td>4.</td><td></td><td>
Walk over the DOM in tree order, starting with the sectioning content element
or sectioning root element at the root of the subtree for which an outline is
to be created, and trigger the first relevant step below for each element as
the walk enters and exits it.</td></tr>

<!-- 4.1. exit the tos element -->
<tr><td></td><td></td><td>.</td></tr>
<tr><td></td><td> > </td><td>
When exiting an element, if that element is the element at the top of the
stack</td></tr>
<tr><td></td><td> - </td><td>
Note - The element being exited is a heading content element or an element
with a hidden attribute.</td></tr>
<tr><td></td><td> - </td><td>
Pop that element from the stack.</td></tr>

<!-- 4.2. the tos element is a heading or hidden -->
<tr><td></td><td></td><td>.</td></tr>
<tr><td></td><td> > </td><td>
If the top of the stack is a heading content element or an element with
a hidden attribute</td></tr>
<tr><td></td><td> - </td><td>
Do nothing.</td></tr>

<!-- 4.3. enter a hidden element -->
<tr><td></td><td></td><td>.</td></tr>
<tr><td></td><td> > </td><td>
When entering an element with a hidden attribute</td></tr>
<tr><td></td><td> - </td><td>
Push the element being entered onto the stack. (This causes the algorithm
to skip that element and any descendants of the element.)</td></tr>

<!-- 4.4. enter a sectioning content element -->
<tr><td></td><td></td><td>.</td></tr>
<tr><td></td><td> > </td><td>
When entering a sectioning content element
- Run these steps:</td></tr>
<tr><td></td><td> - </td><td>
1. - If current outline owner is not null, run these substeps:</td></tr>
<tr><td></td><td> - </td><td>
1.1. - If the current section has no heading, create an implied heading
and let that be the heading for the current section.</td></tr>
<tr><td></td><td> - </td><td>
1.2. - Push current outline owner onto the stack.</td></tr>
<tr><td></td><td> - </td><td>
2. - Let current outline owner be the element that is being entered.</td></tr>
<tr><td></td><td> - </td><td>
3. - Let current section be a newly created section for the current outline
owner element.</td></tr>
<tr><td></td><td> - </td><td>
4. - Associate current outline owner with current section.</td></tr>
<tr><td></td><td> - </td><td>
5. - Let there be a new outline for the new current outline owner, initialized
with just the new current section as the only section in the outline.</td></tr>

<!-- 4.5. exit a sectioning content element, stack not empty -->
<tr><td></td><td></td><td>.</td></tr>
<tr><td></td><td> > </td><td>
When exiting a sectioning content element, if the stack is not empty
- Run these steps:</td></tr>
<tr><td></td><td> - </td><td>
1. - If the current section has no heading, create an implied heading
and let that be the heading for the current section.</td></tr>
<tr><td></td><td> - </td><td>
2. - Pop the top element from the stack, and let the current outline
owner be that element.</td></tr>
<tr><td></td><td> - </td><td>
3. - Let current section be the last section in the outline of
the current outline owner element.</td></tr>
<tr><td></td><td> - </td><td>
4. - Append the outline of the sectioning content element being exited
to the current section. (This does not change which section is the last
section in the outline.)</td></tr>

<!-- 4.6. enter a sectioning root element -->
<tr><td></td><td></td><td>.</td></tr>
<tr><td></td><td> > </td><td>
When entering a sectioning root element
- Run these steps:</td></tr>
<tr><td></td><td> - </td><td>
1. - If current outline owner is not null, push current outline owner
onto the stack.</td></tr>
<tr><td></td><td> - </td><td>
2. - Let current outline owner be the element that is being entered.</td></tr>
<tr><td></td><td> - </td><td>
3. - Let current outline owner’s parent section be current section.</td></tr>
<tr><td></td><td> - </td><td>
4. - Let current section be a newly created section for the current
outline owner element.</td></tr>
<tr><td></td><td> - </td><td>
5. - Let there be a new outline for the new current outline owner, initialized
with just the new current section as the only section in the outline.</td></tr>

<!-- 4.7. exit a sectioning root element, stack not empty -->
<tr><td></td><td></td><td>.</td></tr>
<tr><td></td><td> > </td><td>
When exiting a sectioning root element, if the stack is not empty
- Run these steps:</td></tr>
<tr><td></td><td> - </td><td>
1. - If the current section has no heading, create an implied heading and
let that be the heading for the current section.</td></tr>
<tr><td></td><td> - </td><td>
2. - Let current section be current outline owner’s parent section.</td></tr>
<tr><td></td><td> - </td><td>
3. - Pop the top element from the stack, and let the current outline owner
be that element.</td></tr>

<!-- 4.8. exit a sectioning element, stack is empty -->
<tr><td></td><td></td><td>.</td></tr>
<tr><td></td><td> > </td><td>
When exiting a sectioning content element or a sectioning root element
(when the stack is empty)</td></tr>
<tr><td></td><td> - </td><td>
Note - The current outline owner is the element being exited, and it is
the sectioning content element or a sectioning root element at the root
of the subtree for which an outline is being generated.</td></tr>
<tr><td></td><td> - </td><td>
If the current section has no heading, create an implied heading and let
that be the heading for the current section.</td></tr>
<tr><td></td><td> - </td><td>
Skip to the next step in the overall set of steps. (The walk is over.)</td></tr>

<!-- 4.9. enter a heading content element -->
<tr><td></td><td></td><td>.</td></tr>
<tr><td></td><td> > </td><td>
When entering a heading content element</td></tr>
<tr><td></td><td> - </td><td>
If the current section has no heading, let the element being entered
be the heading for the current section.</td></tr>
<tr><td></td><td> - </td><td>
Otherwise, if the heading of the last section of the outline of the current
outline owner is an implied heading, or if the heading being entered has a
rank equal to or higher than the heading of the last section of the outline
of the current outline owner, then create a new section and append it to the
outline of the current outline owner element, so that this new section is the
new last section of that outline. Let current section be that new section.
Let the element being entered be the new heading for the current section.</td></tr>
<tr><td></td><td> - </td><td>
Otherwise, run these substeps:</td></tr>
<tr><td></td><td> - </td><td>
1. - Let candidate section be current section.</td></tr>
<tr><td></td><td> - </td><td>
2. - Heading loop: If the element being entered has a rank lower than the
rank of the heading of the candidate section, then create a new section,
and append it to candidate section. (This does not change which section is
the last section in the outline.) Let current section be this new section.
Let the element being entered be the new heading for the current section.
Abort these substeps.</td></tr>
<tr><td></td><td> - </td><td>
3. - Let new candidate section be the section that contains candidate section
in the outline of current outline owner.</td></tr>
<tr><td></td><td> - </td><td>
4. - Let candidate section be new candidate section.</td></tr>
<tr><td></td><td> - </td><td>
5. - Return to the step labeled heading loop.</td></tr>
<tr><td></td><td> - </td><td>
Push the element being entered onto the stack. (This causes the algorithm
to skip any descendants of the element.)</td></tr>
<tr><td></td><td> - </td><td>
Note - Recall that h1 has the highest rank, and h6 has the lowest rank.</td></tr>

<!-- 4.10. otherwise -->
<tr><td></td><td></td><td>.</td></tr>
<tr><td></td><td> > </td><td>Otherwise</td></tr>
<tr><td></td><td> - </td><td>Do nothing.</td></tr>

<!-- 4.11. associate nodes with sections -->
<tr><td></td><td></td><td>.</td></tr>
<tr><td></td><td> > </td><td>In addition, whenever the walk exits a node,
after doing the steps above, if the node is not associated with a section yet,
associate the node with the section current section.</td></tr>

<!-- 5. associate non-elements with sections -->
<tr><td>5.</td><td></td><td>Associate all non-element nodes that are in the
subtree for which an outline is being created with the section with which their
parent element is associated.</td></tr>

<!-- 6. associate nodes with headings -->
<tr><td>6.</td><td></td><td>Associate all nodes in the subtree with the heading
of the section with which they are associated, if any.</td></tr>
</table>

The tree of sections created by the algorithm above, or a proper subset thereof,
must be used when generating document outlines, for example when generating
tables of contents.

The outline created for the body element of a Document is the outline of the
entire document.

When creating an interactive table of contents, entries should jump the user to
the relevant sectioning content element, if the section was created for a real
element in the original document, or to the relevant heading content element,
if the section in the tree was generated for a heading in the above process.

Note - Selecting the first section of the document therefore always takes the
user to the top of the document, regardless of where the first heading in the
body is to be found.

The [outline depth](https://w3c.github.io/html/sections.html#outline-depth) of
a heading content element associated with a section section is the number of
sections that are ancestors of section in the outermost outline that section
finds itself in when the outlines of its Document's elements are created, plus
1. The outline depth of a heading content element not associated with a section
is 1.

User agents should provide default headings for sections that do not have
explicit section headings.

```
****************
** Example 28 **

Consider the following snippet:

<body>
  <nav>
    <p><a href="/">Home</a></p>
  </nav>
  <p>Hello world.</p>
  <aside>
    <p>My cat is cute.</p>
  </aside>
</body>

Although it contains no headings, this snippet has three sections:
a document (the body) with two subsections (a nav and an aside).
A user agent could present the outline as follows:

1. Untitled document
   1. Navigation
   2. Sidebar

These default headings ("Untitled document", "Navigation", "Sidebar")
are not specified by this specification, and might vary with the user’s
language, the page’s language, the user’s preferences, the user agent
implementor’s preferences, etc.

****************
```

```
****************
** Example 29 **

The following JavaScript function shows how the tree walk could be
implemented. The root argument is the root of the tree to walk (either
a sectioning content element or a sectioning root element), and the
enter and exit arguments are callbacks that are called with the nodes
as they are entered and exited. [ECMA-262]

function (root, enter, exit) {
  var node = root;
  start: while (node) {
    enter(node);
    if (node.firstChild) {
      node = node.firstChild;
      continue start;
    }
    while (node) {
      exit(node);
      if (node == root) {
        node = null;
      } else if (node.nextSibling) {
        node = node.nextSibling;
        continue start;
      } else {
        node = node.parentNode;
      }
    }
  }
}

****************
```
